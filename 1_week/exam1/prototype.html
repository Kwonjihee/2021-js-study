
<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<title>exam</title>
<link rel="stylesheet" href="common2.css" />
</head>
<body>
<!-- wrapper [s] -->
<div id="wrapper">
	<!-- header [s] -->
	<div id="header">
	</div>
	<!-- header [e] -->
	<hr />
	<!-- container [s] -->
	<div id="container">
		<h1>Prototype</h1>

		
		<!-- Array [s] -->
		<section class="section" id="array">
			<h2>[ Array ]</h2>

			<!-- Array.join -->
			<div class="exam join">
				<h3>Array.join([separator])</h3>
	
				<ul>
					<li>- 배열의 모든 요소를 연결해 하나의 문자열로 만든다.</li>
					<li>- separator : 배열의 각 요소를 구분할 문자열을 지정한다.</li>
				</ul>
<pre class="pre">
var arr = [A, B, C];
var arr2 = [];
</pre>
				<div class="test">
					<div><strong>arr.join('/')</strong></div>
					<div class="result"></div>
				</div>
				<div class="test">
					<div><strong>arr.join()</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- separator를 생략하면 배열의 요소들이 쉼표로 구분된다.</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>arr.join(' ')</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- separator가 빈 문자열이라면 모든 요소들이 사이에 아무 문자도 없이 연결된다.</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>arr2.join()</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 만약 배열에 length가 0이라면 빈 문자열을 반환한다.</li>
					</ul>
				</div>
			</div>
			<!-- // Array.join -->
			<!-- Array.reverse -->
			<div class="exam reverse">
				<h3>Array.reverse()</h3>
	
				<ul>
					<li>- 배열의 순서를 반전한다. (첫 번째 요소는 마지막 요소가 되며 마지막 요소는 첫 번째 요소가 된다.)</li>
					<li>- reverse 메서드는 호출한 배열을 반전하고 <em class="point">원본 배열을 변형하며 그 참조를 반환</em>한다. <br>(새로운 배열을 만들어 반환해주는 것이아니라 기존배열의 순서를 바꾸어 반환해준다.)</li>
				</ul>
	<pre class="pre">
	var arr = [A, B, C];
	</pre>
				<div class="test">
					<div><strong>arr.reverse()</strong></div>
					<div class="result"></div>
				</div>
			</div>
			<!-- // Array.reverse -->
			<!-- Array.sort -->
			<div class="exam sort">
				<h3>Array.sort([compareFunction])</h3>
	
				<ul>
					<li>- 배열의 요소를 적절한 위치에 정렬한 후 그 배열을 반환한다.</li>
					<li>- 정렬 속도와 복잡도는 각 구현방식에 다라 다를 수 있다.</li>
					<li>- <span class="point">복사본이 만들어지는 것이 아니라 원 배열이 정렬된다.</span></li>
					<li>- compareFunction: 정렬 순서를 정의하는 함수이다. 생략하면 배열은 유니코드 코드 포인트 값에 따라 오름차순으로 정렬된다.
						<ul>
							<li>- compareFunction(a, b)이 0보다 작은 경우 a를 b보다 낮은 색인으로 정렬한다.(즉, a가 먼저 온다.)</li>
							<li>- compareFunction(a, b)이 0보다 큰 경우 b를 a보다 낮은 색인으로 정렬한다.</li>
						</ul>
					</li>
				</ul>
<pre class="pre">
var arr = ['banana' , 'Apple', 'Cherry'];
var arr2 = [1, 1000, 41, 5];
</pre>
				<div class="test">
					<div><strong>arr.sort()</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 대문자가 소문자보다 유니코드값이 앞에있기 때문에 Apple, banana, Cherry 순이 아닌 Apple, Cherry, banana순으로 출력된다.</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>arr2.sort()</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 41이 1000보다 앞에 출력되야 할 것 같지만, compareFunction이 제공되지 않으면 기본 문자열로 생각하여 정렬해준다. 그렇기 때문에 1000의 맨앞코드 값1은 41에서의 4보다 유니코드값이 먼저이기때문에 1000보다 41이 먼저 출력되게 된다.</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>arr2.sort(function(a, b){ return a-b; })</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 오름차순으로 정렬</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>arr2.sort(function(a, b){ return b-a; })</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 내림차순으로 정렬</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>
<pre>
arr.sort().reverse();
</pre>
	
					</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 문자열 내림차순으로 정렬</li>
					</ul>
				</div>
			</div>
			<!-- // Array.sort -->
			<!-- Array.concat -->
			<div class="exam concat">
				<h3>Array.concat(string2, string3[, ..., stringN])</h3>
	
				<ul>
					<li>- 매개변수로 전달된 모든 문자열을 호출 문자열에 붙인 새로운 문자열을 반환한다.</li>
					<li>- 그러나 concat()메서드 보다 할당 연산자 (+, +=) 사용자를 하는것이 성능면으로 더 좋다.</li>
					<li>- 혹은 여러개의 배열을 하나늬 배열로 합칠수도 있다.</li>
					<li>- <span class="point">기존 배열을 건드리지 않고 새 배열을 반환</span>한다.</li>
					<li>- string2...stringN : 합칠 문자열</li>
				</ul>
	<pre class="pre">
	var food = '치킨';
	var foods1 = ['마라탕', '김밥'];
	var foods2 = ['부대찌개', '김치찌개'];
	</pre>
				<div class="test">
					<div><strong>food.concat(' 좋아')</strong></div>
					<div class="result"></div>
				</div>
				<div class="test">
					<div><strong>foods1.concat(foods2)</strong></div>
					<div class="result"></div>
				</div>
			</div>
			<!-- // Array.concat -->
			<!-- Array.slice -->
			<div class="exam slice">
				<h3>Array.slice([begin[, end]])</h3>
	
				<ul>
					<li>- slice() 메서드는 어떤 배열의 begin부터 end까지(end 미포함)에 대한 얕은 복사본을 새로운 배열 객체로 반환합니다. 원본 배열은 바뀌지 않습니다</li>
					<li>begin: 0을 시작으로 하는 추출 시작점에 대한 인덱스를 의미</li>
					<li>end: 추출을 종료할 0 기준 인덱스이다.</li>
					<li>slice는 원본을 대체하지 않고 원본배열에서 복사본을 반환한다. (기존 배열을 건드리지 않음)</li>
				</ul>
<pre class="pre">
var arr = [0, 1, 2, 3, 4, 5];
</pre>
				<div class="test">
					<div><strong>arr.slice(2,4)</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- end 인덱스 4를 넣었을때 4번째까지 포함하여 출력하는 것이아니라 4번째 전까지만 출력해준다.</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>arr.slice(2)</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- end 값이 없을경우 지정한 begin 인덱스부터 배열의 끝까지 모두 출력된다.</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>arr.slice(-4, 5)</strong></div>
					<div><strong>arr.slice(-4, -1)</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 음수일 경우 배열의 끝에서부터의 길이를 나타낸다.</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>arr.slice(7)</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- begin 인덱스가 배열의 길이보다 크다면 빈 배열을 반환한다.</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>arr.slice()</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 아무값도 넣지않으면 배열이 그대로 복제된다.</li>
					</ul>
				</div>
			</div>
			<!-- // Array.slice -->
			<!-- Array.splice -->
			<div class="exam splice">
				<h3>Array.splice(start[, deleteCount[, item1[, item2[, ...]]]])</h3>
	
				<ul>
					<li>- 배열의 기존요소를 삭제 또는 교체하거나 새 요소를 추가하여 배열의 내용을 변경한다.</li>
					<li>- <span class="point">기존 배열이 변경</span>된다.</li>
					<li>- start: 배열의 변경을 시작할 인덱스(배열의 길이보다 큰 값이라면 실제 시작 인덱스는 배열의 길이로 설정된다. 음수일 경우 배열의 끝에서부터 요소를 센다.)</li>
					<li>- start: 배열의 변경을 시작할 인덱스</li>
					<li>- deleteCount: 배열에서 제거할 요소의 수(deleteCount가 0 이하라면 어떤 요소도 제거하지 않는다.)</li>
					<li>- item, item, ... : 배열의 추가할 요소, 아무 요소도 지정하지 않으면 splice는 요소를 제거하기만 한다.</li>
				</ul>
<pre class="pre">
var arr = ['A', 'B', 'C'];
</pre>
				<div class="test">
					<div><strong>arr.splice(1, 0, 'Y', 'Z')</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 추가</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>arr.splice(1, 2, '비', '씨')</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 교체</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>arr.splice(1, 1)</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 제거</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>arr.splice(1)</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- start만 입력할 경우 start 인덱스부터 배열의 끝번째의 값까지 모두 제거된다.</li>
					</ul>
				</div>
			</div>
			<!-- // Array.splice -->
			<!-- Array.push -->
			<div class="exam push">
				<h3>Array.push(element1[, ...[, elementN]])</h3>
	
				<ul>
					<li>- 배열의 끝에 하나 이상의 요소를 추가하고, 배열의 새로운 길이를 반환한다.</li>
					<li>- 기존의 배열에 새로운 항목을 맨 뒤에 추가</li>
					<li>- 제네릭합니다. 배열을 닮은 객체에 call() 또는 apply()로 사용될 수 있다.</li>
				</ul>
<pre class="pre">
var arr = ['A', 'B', 'C'];
var arr2 = ['D', 'E', 'F'];
</pre>
				<div class="test">
					<div><strong>arr.push('D', 'E', 'F')</strong></div>
					<div class="result"></div>
				</div>
				<div class="test">
					<div><strong>arr.push.apply(arr2)</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 유사배열 어쩌구 저쩌구~ (찾아보기)</li>
					</ul>
				</div>
			</div>
			<!-- // Array.push -->
			<!-- Array.pop -->
			<div class="exam pop">
				<h3>Array.pop()</h3>
	
				<ul>
					<li>- 마지막 요소를 제거하고 그 요소를 반환한다.</li>
					<li>- 맨 뒤의 원소를 배열에 추출한다.</li>
					<li>- 기존의 배열을 수정한다.</li>
					<li>- 빈 배열에 pop()을 호출하면, undefined 반환한다.</li>
				</ul>
<pre class="pre">
var arr = ['A', 'B', 'C'];
</pre>
				<div class="test">
					<div><strong>arr.pop()</strong></div>
					<div class="result"></div>
				</div>
			</div>
			<!-- // Array.pop -->
			<!-- Array.shift -->
			<div class="exam shift">
				<h3>Array.shift()</h3>
	
				<ul>
					<li>- 배열에서 첫 번째 요소를 제거하고, 제거된 요소를 반환한다.</li>
					<li>- 기존의 배열을 수정한다.</li>
					<li>- 빈 배열인 경우 undefined 반환</li>
				</ul>
<pre class="pre">
var arr = ['A', 'B', 'C'];
</pre>
				<div class="test">
					<div><strong>arr.shift()</strong></div>
					<div class="result"></div>
				</div>
			</div>
			<!-- // Array.shift -->
			<!-- Array.unshift -->
			<div class="exam unshift">
				<h3>Array.unshift([...elementN])</h3>
	
				<ul>
					<li>- 배열에서 첫 번째 요소를 맨 앞쪽에 추가하고, 새로운 길이를 반환한다.</li>
					<li>- 기존의 배열을 수정한다.</li>
					<li>- elementN : 배열 맨 앞에 추가할 요소</li>
				</ul>
<pre class="pre">
var arr = ['A', 'B', 'C'];
</pre>
				<div class="test">
					<div><strong>arr.unshift()</strong></div>
					<div class="result"></div>
				</div>
			</div>
			<!-- // Array.unshift -->
			<!-- Array.toString -->
			<div class="exam toString">
				<h3>Array.toString()</h3>
	
				<ul>
					<li>- 지정된 배열 및 그 요소를 나타내는 <span class="point">문자열을 반환</span></li>
				</ul>
<pre class="pre">
var arr = ['A', 'B', 'C', 1, 2];
</pre>
				<div class="test">
					<div><strong>arr.toString()</strong></div>
					<div class="result"></div>
				</div>
			</div>
			<!-- // Array.toString -->
			<!-- Array.indexOf -->
			<div class="exam indexOf">
				<h3>Array.indexOf(searchElement[, fromIndex])</h3>
	
				<ul>
					<li>- 지정된 요소를 찾을 수 있는 첫 번째 인덱스를 반환하고 존재하지 않으면 -1을 반환한다.</li>
					<li>- searchElement : 배열에서 찾을 요소</li>
					<li>- fromIndex  : 검색을 시작할 색인</li>
				</ul>
<pre class="pre">
var arr = ['A', 'B', 'C', 'D', 'C'];
</pre>
				<div class="test">
					<div><strong>arr.indexOf('C')</strong></div>
					<div class="result"></div>
				</div>
				<div class="test">
					<div><strong>arr.indexOf('E')</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 존재하지 않으면 -1을 반환한다</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>arr.indexOf('C', 3)</strong></div>
					<div class="result"></div>
				</div>
			</div>
			<!-- // Array.indexOf -->
		</section>
		<!-- Array [e] -->
		<!-- String [s] -->
		<section class="section" id="string">
			<h2>[ String ]</h2>

			<!-- String.replace -->
			<div class="exam replace">
				<h3>String.replace(regexp|substr, newSubstr|function)</h3>
	
				<ul>
					<li>- 어떤 패턴에 일치하는 일부 또는 모든 부분이 교체된 <span class="point">새로운 문자열을 반환한다.</span></li>
					<li>- 그 패턴은 문자열이나 정규식(RegEXP)이 될 수 있으며, 교체 문자열은 문자열이나 모든 매치에 대해서 호출된 함수일 수 있다.</li>
					<li>- 패턴이 문자열인 경우, 첫 번째 문자열만 치환이 되며 원래 문자열은 변경되지 않는다.</li>
					<li>- regexp(pattern) : 정규식 객체 또는 리터럴, 일치하는 항목은 newSubStr 또는 지정된 함수가 반환한 값으로 대체된다.</li>
					<li>- substr(pattern) : newSubString으로 대체될 String. 정규식이 아닌 글자 그대로의 문자열로 처리된다. 오직 첫 번째 일치되는 문자열만 교체된다.</li>
					<li>- newSubString(replacement) : 첫번째 파라미터를 대신할 문자열</li>
					<li>- function(replacement) : 주어진 regexp 또는 substr에 일치하는 요소를 대체하는데 사용될 새 하위 문자열을 생성하기 위해 호출되는 함수이다.</li>
				</ul>
<pre class="pre">
var text = 'Hello, world/World/world!';
</pre>
				<div class="test">
					<div><strong>text.replace('world', 'JavaScript')</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 패턴이 문자열인 경우 첫 번째의 문자열만 변경되고 나머지는 변경되지 않는다.</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>text.replace(/world/g, 'JavaScript')</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 변경하려는 문자열을 //로 감싼후(정규식) 뒤에 'g'(글로벌, 전역 매칭)를 붙여 주면 일치하는 모든 문자열을 변경할 수 있다.</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>text.replace(/world/gi, 'JavaScript')</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 정규식 뒤에 'g'(글로벌, 전역 매칭), 'i'(대소문자 구분 안함)를 붙여주면 대소문자 구분없이 모든 일치하는 모든 문자열을 변경할 수 있다.</li>
					</ul>
				</div>
			</div>
			<!-- // String.replace -->
			<!-- String.slice -->
			<div class="exam slice2">
				<h3>String.slice(beginIndex[, endIndex])</h3>
	
				<ul>
					<li>- 문자열의 일부를 추출하면서 <span class="point">새로운 문자열을 반환</span>한다.</li>
					<li>- beginIndex: 추출 시작점이 0부터 시작하는 인덱스, 음수라면 문자열의 끝에서부터의 길이를 나타낸다.</li>
					<li>- endIndex: 0부터 시작하는 추출 종료점, 음수라면 문자열의 끝에서부터의 길이를 나타낸다.</li>
					<li>- slice는 endIndex를 포함하지 않고 추출한다.</li>
				</ul>
<pre class="pre">
var text = 'Hello, world/World/world!';
</pre>
				<div class="test">
					<div><strong>text.slice(0, 4)</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- endIndex를 포함하지 않고 추출합니다.</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>text.slice(-12, -1)</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 음수라면 문자열의 끝에서부터의 길이를 나타낸다.</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>text.slice(32, 35)</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 만약 beginIndex가 strLength보다 크거나 같은 경우 빈 문자열을 반환한다.</li>
					</ul>
				</div>
			</div>
			<!-- // String.slice -->
			<!-- String.split -->
			<div class="exam split">
				<h3>String.split([separator[, limit])</h3>
	
				<ul>
					<li>- String 객체를 지정한 구분자를 이용하여 <span class="point">여러 개의 문자열로 나누어 배열로 반환</span>한다.</li>
					<li>- separator : 원본 문자열을 끊어야 할 부분을 나타내는 문자열이나, 정규표현식</li>
					<li>- limit : 끊어진 문자열의 최대 개수를 나타내는 정수</li>
				</ul>
<pre class="pre">
var text = 'Hello, world/World/world!';
</pre>
				<div class="test">
					<div><strong>text.split('/')</strong></div>
					<div class="result"></div>
				</div>
				<div class="test">
					<div><strong>text.split('/', 2)</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 배열 개수 제한 (지정한 개수 만큼만 배열로 만들어 주고 나머지는 무시한다.)</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>text.split(/\s|\//)</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 정규식 활용하여 문자열을 끊어야 할 부분을 두개이상 설정할 수도 있다.(\s:공백, \/:슬래쉬, |:OR)</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>text.split( (\/) )</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 포획 괄호()를 포함하는 정규표현식일 경우, 포획된 결과도 배열에 포함한다.</li>
					</ul>
				</div>
			</div>
			<!-- // String.split -->
			<!-- String.search -->
			<div class="exam search">
				<h3>String.search(regexp)</h3>
	
				<ul>
					<li>- 정규 표현식과 이 String 객체간에 같은 것을 찾기위한 검색을 실행</li>
					<li>- <span class="point">문자열에 해당하는 패턴이 있으면 그 위치(index)를 반환 해준다. 해당하는 패턴이 없으면 -1 반환</span></li>
					<li>- regexp : 정규 표현식 객체</li>
				</ul>
<pre class="pre">
var text = 'Hello, world/World/world!';
</pre>
				<div class="test">
					<div><strong>text.search('l')</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 지정된 검색 값의 첫 번째 발생 위치를 반환한다.</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>text.search(/\*/)</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 해당하는 패턴을이 없으면 -1반환</li>
					</ul>
				</div>
			</div>
			<!-- // String.search -->
			<!-- String.match -->
			<div class="exam match">
				<h3>String.match(regexp)</h3>
	
				<ul>
					<li>- 문자열이 정규식과 매치되는 부분을 검색하여 <span class="point">일치하는 전체 문자열을 첫 번째 요소로 포함하는 배열을 반환</span>한다.</li>
					<li>- 일치하는 것이 없으면 null이 반환된다.</li>
					<li>- regexp : 정규 표현식 객체</li>
					<li>- 정규식에 g플래그가 포함되어 있지 않으면, RegExp.exec()와 같은 결과를 반환한다.</li>
				</ul>
<pre class="pre">
var text = 'Hello, world/World/world!';
</pre>
				<div class="test">
					<div><strong>text.match(/world/gi)</strong></div>
					<div class="result"></div>
				</div>
			</div>
			<!-- // String.match -->
			<!-- String.trim -->
			<div class="exam trim">
				<h3>String.trim()</h3>
	
				<ul>
					<li>- 메서드는 문자열 양 끝의 공백을 제거한다. trime()은 <span class="point">원본 문자열에는 영향을 주지 않는다</span>.</li>
					<li>- ie 10이상부터 사용가능하다.</li>
				</ul>
<pre class="pre">
var text = '    Hello, world/World/world!    ';
</pre>
				<div class="test">
					<div><strong>text.trim()</strong></div>
					<div class="result"></div>
				</div>
				<div class="test">
					<div><strong>
<pre>
if (!String.prototype.trim) {
	String.prototype.trim = function () {
		return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
	};
}
</pre>
					</strong></div>
					<ul class="explain">
						<li>- 다른 코드 전에 아래 코드를 실행하면 지원하지 않는 환경에서도  String.trim() 을 사용할 수 있다.</li>
					</ul>
				</div>
			</div>
			<!-- // String.trim -->
			<!-- String.trim -->
			<div class="exam indexOf2">
				<h3>String.indexOf(searchValue[, fromIndex])</h3>
	
				<ul>
					<li>- 호출한 String 객체에서 주어진 <span class="point">값과 일치하는 첫 번재 인덱스를 반환한다. 일치하는 값이 없으면 -1 반환</span></li>
					<li>- searchValue : 찾으려는 문자열. 아무 값도 주어지지 않으면 문자열 'undefined'를 찾으려는 문자열로 사용한다.</li>
					<li>- fromIndex : 문자열에서 찾기 시작하는 위치를 나타내는 인덱스 값</li>
				</ul>
<pre class="pre">
var text = 'Hello, world/World/world!';
</pre>
				<div class="test">
					<div><strong>text.indexOf('world')</strong></div>
					<div class="result"></div>
				</div>
				<div class="test">
					<div><strong>text.indexOf('world', 8)</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- indexOf는 대소문자를 구분한다.</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>text.indexOf('hi')</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 찾는 문자열이 없으면 -1 반환</li>
					</ul>
				</div>
				<div class="test">
					<div><strong>text.lastIndexOf('world')</strong></div>
					<div class="result"></div>
					<ul class="explain">
						<li>- 역순으로 탐색(오른쪽부터 검색)</li>
					</ul>
				</div>
			</div>
			<!-- // String.indexOf -->
		</section>
		<!-- String [e] -->
		<!-- Object [s] -->
		<section class="section" id="object">
			<h2>[ Object ]</h2>

			<!-- String.replace -->
			<div class="exam hasOwnProperty">
				<h3>String.hasOwnProperty(prop)</h3>
	
				<ul>
					<li>- 객체가 특정 프로퍼티를 가지고 있는지를 나타내는 불리언 값을 반환한다.</li>
					<li>- prop : 테스트하려는 프로퍼티의 명칭</li>
					<li>- 객체의 속성이 상속받지 않은 속성인지 알려준다.</li>
					<li>- 자신의 속성이면 true, 부모의 속성이거나 아예 속성이 아니면 false를 반환한다.</li>
				</ul>
<pre class="pre">
var obj = {
	prop : '123'
}
</pre>
				<div class="test">
					<div><strong>obj.hasOwnProperty('prop')</strong></div>
					<div class="result"></div>
				</div>
				<div class="test">
					<div><strong>obj.hasOwnProperty('prop2')</strong></div>
					<div class="result"></div>
				</div>
			</div>
			<!-- // String.hasOwnProperty -->
		</section>
		<!-- Object [s] -->


	</div>
	<!-- container [e] -->
	<hr />
	<!-- footer [s] -->
	<div id="footer">
	</div>
	<!-- footer [e] -->
</div>
<!-- wrapper [e] -->
</body>

<!--/* jQuery library */-->
<script src="https://code.jquery.com/jquery-latest.js"></script> 
<script>
// jQuery code
$(function(){

	/*
		Array.join()
	*/
	var join = $('.join');
	var join_arr = ['A', 'B', 'C'];
	var join_arr2 = [];

	var join_test1 = join_arr.join('/');
	 join.find('.test:eq(0) .result').append('<p><span>'+join_test1+'</span></p>');
	var join_test2 = join_arr.join();
	join.find('.test:eq(1) .result').append('<p><span>'+join_test2+'</span></p>');
	var join_test3 = join_arr.join(' ');
	 join.find('.test:eq(2) .result').append('<p><span>'+join_test3+'</span></p>');
	var join_test4 = join_arr2.join();
	join.find('.test:eq(3) .result').append('<p><span>'+join_test4+'</span></p>');


	/*
		Array.reverse()
	*/
	var reverse = $('.reverse');
	var reverse_arr = ['A', 'B', 'C'];

	var reverse_test1 = reverse_arr.reverse();
	reverse.find('.test:eq(0) .result').append('<p><span>'+reverse_test1.join(' ')+'</span></p>');


	/*
		Array.sort()
	*/
	var sort = $('.sort');
	var sort_arr = ['banana' , 'Apple', 'Cherry'];
	var sort_arr2 = [1, 1000, 41, 5];

	var sort_test1 = sort_arr.sort();
	sort.find('.test:eq(0) .result').append('<p><span>'+sort_test1.join(' ')+'</span></p>');
	var sort_test2 = sort_arr2.sort();
	sort.find('.test:eq(1) .result').append('<p><span>'+sort_test2.join(' ')+'</span></p>');
	var sort_test3 = sort_arr2.sort(function(a,b){return a-b;});
	sort.find('.test:eq(2) .result').append('<p><span>'+sort_test3.join(' ')+'</span></p>');
	var sort_test4 = sort_arr2.sort(function(a,b){return b-a;});
	sort.find('.test:eq(3) .result').append('<p><span>'+sort_test4.join(' ')+'</span></p>');
	var sort_test5 = sort_arr.sort().reverse();
	sort.find('.test:eq(4) .result').append('<p><span>'+sort_test5.join(' ')+'</span></p>');


	/*
		Array.concat()
	*/
	var concat = $('.concat');
	var concat_food = '치킨';
	var concat_foods1 = ['마라탕', '김밥'];
	var concat_foods2 = ['부대찌개', '김치찌개'];

	var concat_test1 = concat_food.concat(' 좋아');
	concat.find('.test:eq(0) .result').append('<p><span>'+concat_test1+'</span></p>');
	var concat_test2 = concat_foods1.concat(concat_foods2);
	concat.find('.test:eq(1) .result').append('<p><span>'+concat_test2.join(' ')+'</span></p>');


	/*
		Array.slice()
	*/
	var slice = $('.slice');
	var slice_arr = [0, 1, 2, 3, 4, 5];

	var slice_test1 = slice_arr.slice(2, 4);
	slice.find('.test:eq(0) .result').append('<p><span>'+slice_test1.join(' ')+'</span></p>');
	var slice_test2 = slice_arr.slice(2);
	slice.find('.test:eq(1) .result').append('<p><span>'+slice_test2.join(' ')+'</span></p>');
	var slice_test3 = slice_arr.slice(-4, -1);
	// var slice_test3 = slice_arr.slice(-4, 5); //위에 것과 결과 동일
	slice.find('.test:eq(2) .result').append('<p><span>'+slice_test3.join(' ')+'</span></p>');
	var slice_test4 = slice_arr.slice(7);
	slice.find('.test:eq(3) .result').append('<p><span>'+slice_test4.join(' ')+'</span></p>');
	var slice_test5 = slice_arr.slice();
	slice.find('.test:eq(4) .result').append('<p><span>'+slice_test5.join(' ')+'</span></p>');


	/*
		Array.splice()
	*/
	var splice = $('.splice');
	var splice_arr = ['A', 'B', 'C'];
	
	var splice_test1 = splice_arr.slice();
	splice_test1.splice(1, 0, 'Y', 'Z');
	splice.find('.test:eq(0) .result').append('<p><span>'+splice_test1.join(' ')+'</span></p>');
	var splice_test2 = splice_arr.slice();
	splice_test2.splice(1, 2, '비', '씨');
	splice.find('.test:eq(1) .result').append('<p><span>'+splice_test2.join(' ')+'</span></p>');
	var splice_test3 = splice_arr.slice();
	splice_test3.splice(1, 1);
	splice.find('.test:eq(2) .result').append('<p><span>'+splice_test3.join(' ')+'</span></p>');
	var splice_test4 = splice_arr.slice();
	splice_test4.splice(1);
	splice.find('.test:eq(3) .result').append('<p><span>'+splice_test4.join(' ')+'</span></p>');


	/*
		Array.push()
	*/
	var push = $('.push');
	var push_arr = ['A', 'B', 'C'];
	var push_arr2 = ['D', 'E', 'F'];

	var push_test1 = push_arr.slice();
	push_test1.push('D', 'E', 'F');
	push.find('.test:eq(0) .result').append('<p><span>'+push_test1.join(' ')+'</span></p>');
	var push_test2 = push_arr.slice();
	Array.prototype.push.apply(push_test2, push_arr2);
	push.find('.test:eq(1) .result').append('<p><span>'+push_test2.join(' ')+'</span></p>');


	/*
		Array.pop()
	*/
	var pop = $('.pop');
	var pop_arr = ['A', 'B', 'C'];

	var pop_test1 = pop_arr.slice();
	pop_test1.pop();
	pop.find('.test:eq(0) .result').append('<p><span>'+pop_test1.join(' ')+'</span></p>');


	/*
		Array.shift()
	*/
	var shift = $('.shift');
	var shift_arr = ['A', 'B', 'C'];
	var shift_test1 = shift_arr.shift();
	shift.find('.test:eq(0) .result').append('<p><span>'+shift_test1+'</span> : 배열에서 제거되고 반환된 값</p>');
	shift.find('.test:eq(0) .result').append('<p><span>'+shift_arr+'</span> : 제거되고 남은 배열 (arr)</p>');


	/*
		Array.unshift()
	*/
	var unshift = $('.unshift');
	var unshift_arr = ['A', 'B', 'C'];
	var unshift_test1 = unshift_arr.unshift('Y', 'Z');
	unshift.find('.test:eq(0) .result').append('<p><span>'+unshift_arr.join(' ')+'</span>');


	/*
		Array.toString()
	*/
	var toString = $('.toString');
	var toString_arr = ['A', 'B', 'C', 1, 2];
	var toString_test1 = toString_arr.toString();
	toString.find('.test:eq(0) .result').append('<p><span>'+toString_arr+'</span>');


	/*
		Array.indexOf()
	*/
	var indexOf = $('.indexOf');
	var indexOf_arr = ['A', 'B', 'C', 'D', 'C'];
	var indexOf_test1 = indexOf_arr.indexOf('C');
	indexOf.find('.test:eq(0) .result').append('<p><span>'+indexOf_test1+'</span>');
	var indexOf_test2 = indexOf_arr.indexOf('E');
	indexOf.find('.test:eq(1) .result').append('<p><span>'+indexOf_test2+'</span>');
	var indexOf_test3 = indexOf_arr.indexOf('C', 3);
	indexOf.find('.test:eq(2) .result').append('<p><span>'+indexOf_test3+'</span>');











	/*
		String.replace()
	*/
	var replace = $('.replace');
	var replace_text = 'Hello, world/World/world!';
	var replace_test1 = replace_text.replace('world', 'JavaScript');
	replace.find('.test:eq(0) .result').append('<p><span>'+replace_test1+'</span></p>');
	var replace_test2 = replace_text.replace(/world/g, 'JavaScript');
	replace.find('.test:eq(1) .result').append('<p><span>'+replace_test2+'</span></p>');
	var replace_test3 = replace_text.replace(/world/gi, 'JavaScript');
	replace.find('.test:eq(2) .result').append('<p><span>'+replace_test3+'</span></p>');
	
	
	/*
		String.slice()
	*/
	var slice2 = $('.slice2');
	var replace2_text = 'Hello, world/World/world!';
	var replace2_test1 = replace2_text.slice(0, 4);
	slice2.find('.test:eq(0) .result').append('<p><span>'+replace2_test1+'</span></p>');
	var replace2_test2 = replace2_text.slice(-12, -1);
	slice2.find('.test:eq(1) .result').append('<p><span>'+replace2_test2+'</span></p>');
	var replace2_test3 = replace2_text.slice(32, 35);
	slice2.find('.test:eq(2) .result').append('<p><span>'+replace2_test3+'</span></p>');
	
	
	/*
		String.split()
	*/
	var split = $('.split');
	var split_text = 'Hello, world/World/world!';
	var split_test1 = split_text.split('/');
	for(var i=0 in split_test1) {
		split.find('.test:eq(0) .result').append('<p><span>'+split_test1[i]+'</span></p>');
	}
	var split_test2 = split_text.split('/', 2);
	for(var i=0 in split_test2) {
		split.find('.test:eq(1) .result').append('<p><span>'+split_test2[i]+'</span></p>');
	}
	var split_test3 = split_text.split(/\s|\//);
	for(var i=0 in split_test3) {
		split.find('.test:eq(2) .result').append('<p><span>'+split_test3[i]+'</span></p>');
	}
	var split_test4 = split_text.split(/(\/)/);
	for(var i=0 in split_test4) {
		split.find('.test:eq(3) .result').append('<p><span>'+split_test4[i]+'</span></p>');
	}
	
	
	/*
		String.search()
	*/
	var search = $('.search');
	var search_text = 'Hello, world/World/world!';
	var search_test1 = search_text.search('l');
	search.find('.test:eq(0) .result').append('<p><span>'+search_test1+'</span></p>');
	var search_test2 = search_text.search(/\*/);
	search.find('.test:eq(1) .result').append('<p><span>'+search_test2+'</span></p>');
	
	
	/*
		String.match()
	*/
	var match = $('.match');
	var match_text = 'Hello, world/World/world!';
	var match_test1 = match_text.match(/world/gi);
	for(var i=0 in match_test1) {
		match.find('.test:eq(0) .result').append('<p><span>'+match_test1[i]+'</span></p>');
	}
	
	
	/*
		String.trim()
	*/
	var trim = $('.trim');
	var trim_text = '      Hello, world/World/world!      ';
	if (!String.prototype.trim) {
		String.prototype.trim = function () {
			return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
		};
	}
	var trim_test1 = trim_text.trim();
	trim.find('.test:eq(0) .result').append('<p><span>'+trim_test1+'</span></p>');
	
	
	/*
		String.indexOf()
	*/
	var indexOf2 = $('.indexOf2');
	var indexOf2_text = 'Hello, world / World / world!';
	var indexOf2_test1 = indexOf2_text.indexOf('world');
	indexOf2.find('.test:eq(0) .result').append('<p><span>'+indexOf2_test1+'</span></p>');
	var indexOf2_test2 = indexOf2_text.indexOf('world', 8);
	indexOf2.find('.test:eq(1) .result').append('<p><span>'+indexOf2_test2+'</span></p>');
	var indexOf2_test3 = indexOf2_text.indexOf('hi');
	indexOf2.find('.test:eq(2) .result').append('<p><span>'+indexOf2_test3+'</span></p>');
	var indexOf2_test4 = indexOf2_text.lastIndexOf('world');
	indexOf2.find('.test:eq(3) .result').append('<p><span>'+indexOf2_test4+'</span></p>');
	
	
	/*
		String.hasOwnProperty()
	*/
	var hasOwnProperty = $('.hasOwnProperty');
	var hasOwnProperty_obj = {
		prop : '123'
	};
	var hasOwnProperty_test1 = hasOwnProperty_obj.hasOwnProperty('prop');
	hasOwnProperty.find('.test:eq(0) .result').append('<p><span>'+hasOwnProperty_test1+'</span></p>');
	var hasOwnProperty_test2 = hasOwnProperty_obj.hasOwnProperty('prop2');
	hasOwnProperty.find('.test:eq(1) .result').append('<p><span>'+hasOwnProperty_test2+'</span></p>');




	//js 책갈피
	
});
</script>
</html>
