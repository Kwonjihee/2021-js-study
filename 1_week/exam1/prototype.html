
<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<title>exam</title>
<link rel="stylesheet" href="common2.css" />
</head>
<body>
<!-- wrapper [s] -->
<div id="wrapper">
	<!-- header [s] -->
	<div id="header">
	</div>
	<!-- header [e] -->
	<hr />
	<!-- container [s] -->
	<div id="container">
		<h1>Prototype</h1>

		<section class="section">
			<h2>[ Array ]</h2>

			<!-- Array.join() -->
			<div class="exam join">
				<h3>Array.join([separator])</h3>
	
				<ul>
					<li>- 배열의 모든 요소를 연결해 하나의 문자열로 만든다.</li>
					<li>- separator : 배열의 각 요소를 구분할 문자열을 지정한다.</li>
				</ul>
<pre class="pre">
var arr = [A, B, C];
var arr2 = [];
</pre>
				<div class="test">
					<p><strong>arr.join('/')</strong></p>
					<p class="result"></p>
				</div>
				<div class="test">
					<p><strong>arr.join()</strong></p>
					<p class="result"></p>
					<ul class="explain">
						<li>- separator를 생략하면 배열의 요소들이 쉼표로 구분된다.</li>
					</ul>
				</div>
				<div class="test">
					<p><strong>arr.join(' ')</strong></p>
					<p class="result"></p>
					<ul class="explain">
						<li>- separator가 빈 문자열이라면 모든 요소들이 사이에 아무 문자도 없이 연결된다.</li>
					</ul>
				</div>
				<div class="test">
					<p><strong>arr2.join()</strong></p>
					<p class="result"></p>
					<ul class="explain">
						<li>- 만약 배열에 length가 0이라면 빈 문자열을 반환한다.</li>
					</ul>
				</div>
			</div>
			<!-- // Array.join() -->
			<!-- Array.reverse() -->
			<div class="exam reverse">
				<h3>Array.reverse()</h3>
	
				<ul>
					<li>- 배열의 순서를 반전한다. (첫 번째 요소는 마지막 요소가 되며 마지막 요소는 첫 번째 요소가 된다.)</li>
					<li>- reverse 메서드는 호출한 배열을 반전하고 <em class="point">원본 배열을 변형하며 그 참조를 반환</em>한다. <br>(새로운 배열을 만들어 반환해주는 것이아니라 기존배열의 순서를 바꾸어 반환해준다.)</li>
				</ul>
	<pre class="pre">
	var arr = [A, B, C];
	</pre>
				<div class="test">
					<p><strong>arr.reverse()</strong></p>
					<p class="result"></p>
				</div>
			</div>
			<!-- // Array.reverse() -->
			<!-- Array.sort() -->
			<div class="exam sort">
				<h3>Array.sort([compareFunction])</h3>
	
				<ul>
					<li>- 배열의 요소를 적절한 위치에 정렬한 후 그 배열을 반환한다.</li>
					<li>- 정렬 속도와 복잡도는 각 구현방식에 다라 다를 수 있다.</li>
					<li>- <span class="point">복사본이 만들어지는 것이 아니라 원 배열이 정렬된다.</span></li>
					<li>- compareFunction: 정렬 순서를 정의하는 함수이다. 생략하면 배열은 유니코드 코드 포인트 값에 따라 오름차순으로 정렬된다.
						<ul>
							<li>- compareFunction(a, b)이 0보다 작은 경우 a를 b보다 낮은 색인으로 정렬한다.(즉, a가 먼저 온다.)</li>
							<li>- compareFunction(a, b)이 0보다 큰 경우 b를 a보다 낮은 색인으로 정렬한다.</li>
						</ul>
					</li>
				</ul>
<pre class="pre">
var arr = ['banana' , 'Apple', 'Cherry'];
var arr2 = [1, 1000, 41, 5];
</pre>
				<div class="test">
					<p><strong>arr.sort()</strong></p>
					<p class="result"></p>
					<ul class="explain">
						<li>- 대문자가 소문자보다 유니코드값이 앞에있기 때문에 Apple, banana, Cherry 순이 아닌 Apple, Cherry, banana순으로 출력된다.</li>
					</ul>
				</div>
				<div class="test">
					<p><strong>arr2.sort()</strong></p>
					<p class="result"></p>
					<ul class="explain">
						<li>- 41이 1000보다 앞에 출력되야 할 것 같지만, compareFunction이 제공되지 않으면 기본 문자열로 생각하여 정렬해준다. 그렇기 때문에 1000의 맨앞코드 값1은 41에서의 4보다 유니코드값이 먼저이기때문에 1000보다 41이 먼저 출력되게 된다.</li>
					</ul>
				</div>
				<div class="test">
					<p><strong>arr2.sort(function(a, b){ return a-b; })</strong></p>
					<p class="result"></p>
					<ul class="explain">
						<li>- 오름차순으로 정렬</li>
					</ul>
				</div>
				<div class="test">
					<p><strong>arr2.sort(function(a, b){ return b-a; })</strong></p>
					<p class="result"></p>
					<ul class="explain">
						<li>- 내림차순으로 정렬</li>
					</ul>
				</div>
				<div class="test">
					<p><strong>
<pre>
arr.sort().reverse();
</pre>
	
					</strong></p>
					<p class="result"></p>
					<ul class="explain">
						<li>- 문자열 내림차순으로 정렬</li>
					</ul>
				</div>
			</div>
			<!-- // Array.sort() -->
			<!-- Array.concat() -->
			<div class="exam concat">
				<h3>Array.concat(string2, string3[, ..., stringN])</h3>
	
				<ul>
					<li>- 매개변수로 전달된 모든 문자열을 호출 문자열에 붙인 새로운 문자열을 반환한다.</li>
					<li>- 그러나 concat()메서드 보다 할당 연산자 (+, +=) 사용자를 하는것이 성능면으로 더 좋다.</li>
					<li>- 혹은 여러개의 배열을 하나늬 배열로 합칠수도 있다.</li>
					<li>- <span class="point">기존 배열을 건드리지 않고 새 배열을 반환</span>한다.</li>
					<li>- string2...stringN : 합칠 문자열</li>
				</ul>
	<pre class="pre">
	var food = '치킨';
	var foods1 = ['마라탕', '김밥'];
	var foods2 = ['부대찌개', '김치찌개'];
	</pre>
				<div class="test">
					<p><strong>food.concat(' 좋아')</strong></p>
					<p class="result"></p>
				</div>
				<div class="test">
					<p><strong>foods1.concat(foods2)</strong></p>
					<p class="result"></p>
				</div>
			</div>
			<!-- // Array.concat() -->
			<!-- Array.slice() -->
			<div class="exam slice">
				<h3>Array.slice([begin[, end]])</h3>
	
				<ul>
					<li>- slice() 메서드는 어떤 배열의 begin부터 end까지(end 미포함)에 대한 얕은 복사본을 새로운 배열 객체로 반환합니다. 원본 배열은 바뀌지 않습니다</li>
					<li>begin: 0을 시작으로 하는 추출 시작점에 대한 인덱스를 의미</li>
					<li>end: 추출을 종료할 0 기준 인덱스이다.</li>
					<li>slice는 원본을 대체하지 않고 원본배열에서 복사본을 반환한다. (기존 배열을 건드리지 않음)</li>
				</ul>
<pre class="pre">
var arr = [0, 1, 2, 3, 4, 5];
</pre>
				<div class="test">
					<p><strong>arr.slice(2,4)</strong></p>
					<p class="result"></p>
					<ul class="explain">
						<li>- end 인덱스 4를 넣었을때 4번째까지 포함하여 출력하는 것이아니라 4번째 전까지만 출력해준다.</li>
					</ul>
				</div>
				<div class="test">
					<p><strong>arr.slice(2)</strong></p>
					<p class="result"></p>
					<ul class="explain">
						<li>- end 값이 없을경우 지정한 begin 인덱스부터 배열의 끝까지 모두 출력된다.</li>
					</ul>
				</div>
				<div class="test">
					<p><strong>arr.slice(-4, 5)</strong></p>
					<p><strong>arr.slice(-4, -1)</strong></p>
					<p class="result"></p>
					<ul class="explain">
						<li>- 음수일 경우 배열의 끝에서부터의 길이를 나타낸다.</li>
					</ul>
				</div>
				<div class="test">
					<p><strong>arr.slice(7)</strong></p>
					<p class="result"></p>
					<ul class="explain">
						<li>- begin 인덱스가 배열의 길이보다 크다면 빈 배열을 반환한다.</li>
					</ul>
				</div>
				<div class="test">
					<p><strong>arr.slice()</strong></p>
					<p class="result"></p>
					<ul class="explain">
						<li>- 아무값도 넣지않으면 배열이 그대로 복제된다.</li>
					</ul>
				</div>
			</div>
			<!-- // Array.slice() -->
			<!-- Array.splice() -->
			<div class="exam splice">
				<h3>Array.splice(start[, deleteCount[, item1[, item2[, ...]]]])</h3>
	
				<ul>
					<li>- 배열의 기존요소를 삭제 또는 교체하거나 새 요소를 추가하여 배열의 내용을 변경한다.</li>
					<li>- <span class="point">기존 배열이 변경</span>된다.</li>
					<li>- start: 배열의 변경을 시작할 인덱스(배열의 길이보다 큰 값이라면 실제 시작 인덱스는 배열의 길이로 설정된다. 음수일 경우 배열의 끝에서부터 요소를 센다.)</li>
					<li>- start: 배열의 변경을 시작할 인덱스</li>
					<li>- deleteCount: 배열에서 제거할 요소의 수(deleteCount가 0 이하라면 어떤 요소도 제거하지 않는다.)</li>
					<li>- item, item, ... : 배열의 추가할 요소, 아무 요소도 지정하지 않으면 splice는 요소를 제거하기만 한다.</li>
				</ul>
<pre class="pre">
var arr = ['A', 'B', 'C'];
</pre>
				<div class="test">
					<p><strong>arr.splice(1, 0, 'Y', 'Z')</strong></p>
					<p class="result"></p>
					<ul class="explain">
						<li>- 추가</li>
					</ul>
				</div>
				<div class="test">
					<p><strong>arr.splice(1, 2, '비', '씨')</strong></p>
					<p class="result"></p>
					<ul class="explain">
						<li>- 교체</li>
					</ul>
				</div>
				<div class="test">
					<p><strong>arr.splice(1, 1)</strong></p>
					<p class="result"></p>
					<ul class="explain">
						<li>- 제거</li>
					</ul>
				</div>
				<div class="test">
					<p><strong>arr.splice(1)</strong></p>
					<p class="result"></p>
					<ul class="explain">
						<li>- start만 입력할 경우 start 인덱스부터 배열의 끝번째의 값까지 모두 제거된다.</li>
					</ul>
				</div>
			</div>
			<!-- // Array.splice() -->
			<!-- Array.push() -->
			<div class="exam push">
				<h3>Array.push(element1[, ...[, elementN]])</h3>
	
				<ul>
					<li>- 배열의 끝에 하나 이상의 요소를 추가하고, 배열의 새로운 길이를 반환한다.</li>
					<li>- 기존의 배열에 새로운 항목을 맨 뒤에 추가</li>
					<li>- 제네릭합니다. 배열을 닮은 객체에 call() 또는 apply()로 사용될 수 있다.</li>
				</ul>
<pre class="pre">
var arr = ['A', 'B', 'C'];
var arr2 = ['D', 'E', 'F'];
</pre>
				<div class="test">
					<p><strong>arr.push('D', 'E', 'F')</strong></p>
					<p class="result"></p>
				</div>
				<div class="test">
					<p><strong>arr.push.apply(arr2)</strong></p>
					<p class="result"></p>
					<ul class="explain">
						<li>- 유사배열 어쩌구 저쩌구~ (찾아보기)</li>
					</ul>
				</div>
			</div>
			<!-- // Array.push() -->
			<!-- Array.pop() -->
			<div class="exam pop">
				<h3>Array.pop()</h3>
	
				<ul>
					<li>- 마지막 요소를 제거하고 그 요소를 반환한다.</li>
					<li>- 맨 뒤의 원소를 배열에 추출한다.</li>
					<li>- 기존의 배열을 수정한다.</li>
					<li>- 빈 배열에 pop()을 호출하면, undefined 반환한다.</li>
				</ul>
<pre class="pre">
var arr = ['A', 'B', 'C'];
</pre>
				<div class="test">
					<p><strong>arr.pop()</strong></p>
					<p class="result"></p>
				</div>
			</div>
			<!-- // Array.pop() -->
			<!-- Array.shift() -->
			<div class="exam shift">
				<h3>Array.shift()</h3>
	
				<ul>
					<li>- 배열에서 첫 번째 요소를 추출한다.</li>
					<li>- 기존의 배열을 수정한다.</li>
					<li>- 빈 배열인 경우 undefined 반환</li>
					<li>- 의도적인 일반형태로서 배열과 유사한 형태의 객체에서 호출하거나 적용할 수 있다.</li>
				</ul>
<pre class="pre">
var arr = ['A', 'B', 'C'];
</pre>
				<div class="test">
					<p><strong>arr.shift()</strong></p>
					<p class="result"></p>
				</div>
			</div>
			<!-- // Array.shift() -->
		</section>

		<!--html 책갈피-->

	</div>
	<!-- container [e] -->
	<hr />
	<!-- footer [s] -->
	<div id="footer">
	</div>
	<!-- footer [e] -->
</div>
<!-- wrapper [e] -->
</body>

<!--/* jQuery library */-->
<script src="https://code.jquery.com/jquery-latest.js"></script> 
<script>
// jQuery code
$(function(){

	/*
		Exam1) Array.join()
	*/
	var join = $('.join');
	var join_arr = ['A', 'B', 'C'];
	var join_arr2 = [];

	var join_test1 = join_arr.join('/');
	 join.find('.test:eq(0) .result').append(join_test1);
	var join_test2 = join_arr.join();
	join.find('.test:eq(1) .result').append(join_test2);
	var join_test3 = join_arr.join(' ');
	 join.find('.test:eq(2) .result').append(join_test3);
	var join_test4 = join_arr2.join();
	join.find('.test:eq(3) .result').append(join_test4);



	/*
		Exam2) Array.reverse()
	*/
	var reverse = $('.reverse');
	var reverse_arr = ['A', 'B', 'C'];

	var reverse_test1 = reverse_arr.reverse();
	reverse.find('.test:eq(0) .result').append(reverse_test1.join(' '));



	/*
		Exam3) Array.sort()
	*/
	var sort = $('.sort');
	var sort_arr = ['banana' , 'Apple', 'Cherry'];
	var sort_arr2 = [1, 1000, 41, 5];

	var sort_test1 = sort_arr.sort();
	sort.find('.test:eq(0) .result').append(sort_test1.join(' '));
	var sort_test2 = sort_arr2.sort();
	sort.find('.test:eq(1) .result').append(sort_test2.join(' '));
	var sort_test3 = sort_arr2.sort(function(a,b){return a-b;});
	sort.find('.test:eq(2) .result').append(sort_test3.join(' '));
	var sort_test4 = sort_arr2.sort(function(a,b){return b-a;});
	sort.find('.test:eq(3) .result').append(sort_test4.join(' '));
	var sort_test5 = sort_arr.sort().reverse();
	sort.find('.test:eq(4) .result').append(sort_test5.join(' '));



	/*
		Exam5) Array.concat()
	*/
	var concat = $('.concat');
	var concat_food = '치킨';
	var concat_foods1 = ['마라탕', '김밥'];
	var concat_foods2 = ['부대찌개', '김치찌개'];

	var concat_test1 = concat_food.concat(' 좋아');
	concat.find('.test:eq(0) .result').append(concat_test1);
	var concat_test2 = concat_foods1.concat(concat_foods2);
	concat.find('.test:eq(1) .result').append(concat_test2.join(' '));



	/*
		Exam6) Array.slice()
	*/
	var slice = $('.slice');
	var slice_arr = [0, 1, 2, 3, 4, 5];

	var slice_test1 = slice_arr.slice(2, 4);
	slice.find('.test:eq(0) .result').append(slice_test1.join(' '));
	var slice_test2 = slice_arr.slice(2);
	slice.find('.test:eq(1) .result').append(slice_test2.join(' '));
	var slice_test3 = slice_arr.slice(-4, -1);
	// var slice_test3 = slice_arr.slice(-4, 5); //위에 것과 결과 동일
	slice.find('.test:eq(2) .result').append(slice_test3.join(' '));
	var slice_test4 = slice_arr.slice(7);
	slice.find('.test:eq(3) .result').append(slice_test4.join(' '));
	var slice_test5 = slice_arr.slice();
	slice.find('.test:eq(4) .result').append(slice_test5.join(' '));



	/*
		Exam6) Array.splice()
	*/
	var splice = $('.splice');
	var splice_arr = ['A', 'B', 'C'];
	
	var splice_test1 = splice_arr.slice();
	splice_test1.splice(1, 0, 'Y', 'Z');
	splice.find('.test:eq(0) .result').append(splice_test1.join(' '));
	var splice_test2 = splice_arr.slice();
	splice_test2.splice(1, 2, '비', '씨');
	splice.find('.test:eq(1) .result').append(splice_test2.join(' '));
	var splice_test3 = splice_arr.slice();
	splice_test3.splice(1, 1);
	splice.find('.test:eq(2) .result').append(splice_test3.join(' '));
	var splice_test4 = splice_arr.slice();
	splice_test4.splice(1);
	splice.find('.test:eq(3) .result').append(splice_test4.join(' '));



	/*
		Exam7) Array.push()
	*/
	var push = $('.push');
	var push_arr = ['A', 'B', 'C'];
	var push_arr2 = ['D', 'E', 'F'];

	var push_test1 = push_arr.slice();
	push_test1.push('D', 'E', 'F');
	push.find('.test:eq(0) .result').append(push_test1.join(' '));
	var push_test2 = push_arr.slice();
	Array.prototype.push.apply(push_test2, push_arr2);
	push.find('.test:eq(1) .result').append(push_test2.join(' '));



	/*
		Exam8) Array.pop()
	*/
	var pop = $('.pop');
	var pop_arr = ['A', 'B', 'C'];

	var pop_test1 = pop_arr.slice();
	pop_test1.pop();
	pop.find('.test:eq(0) .result').append(pop_test1.join(' '));



	/*
		Exam9) Array.shift()
	*/
	var shift = $('.shift');
	var shift_arr = ['A', 'B', 'C'];
	var shift_test1 = shift_arr.shift();
	console.log(shift_test1);





	//js 책갈피
	
});
</script>
</html>
